{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Splinter (Supabase Postgres LINTER)","text":"<p>This project maintains a set of lints for Supabase projects. It uses SQL queries to identify common database schema issues. Some lints are general purpose for Postgres projects while others are specific to Supabase features, storing their data in Postgres e.g. auth and storage.</p>"},{"location":"0001_unindexed_foreign_keys/","title":"Unindexed Foreign Keys","text":"<p>Level: INFO</p>"},{"location":"0001_unindexed_foreign_keys/#rationale","title":"Rationale","text":"<p>In relational databases, indexing foreign key columns is a standard practice for improving query performance. Indexing these columns is recommended in most cases because it improves query join performance along a declared relationship.</p>"},{"location":"0001_unindexed_foreign_keys/#what-is-a-foreign-key","title":"What is a Foreign Key?","text":"<p>A foreign key is a constraint on a column (or set of columns) that enforces a relationship between two tables. For example, a foreign key from <code>book.author_id</code> to <code>author.id</code> enforces that every value in <code>book.author_id</code> exists in <code>author.id</code>. Once the foriegn key is declared, it is not possible to insert a value into <code>book.author_id</code> that does not exist in <code>author.id</code>. Similarly, Postgres will not allow us to delete a value from <code>author.id</code> that is referenced by <code>book.author_id</code>. This concept is known as referential integrity.</p>"},{"location":"0001_unindexed_foreign_keys/#why-index-foreign-key-columns","title":"Why Index Foreign Key Columns?","text":"<p>Given that foreign keys define relationships among tables, it is common to use foreign key columns in join conditions when querying the database. Adding an index to the columns making up the foreign key improves the performance of those joins and reduces database resource consumption.</p> <pre><code>select\nbook.id,\nbook.title,\nauthor.name\nfrom\nbook\njoin author\n-- Both sides of the following condition should be indexed\n-- for best performance\non book.author_id = author.id\n</code></pre>"},{"location":"0001_unindexed_foreign_keys/#how-to-resolve","title":"How to Resolve","text":"<p>Given a table:</p> <pre><code>create table book (\nid serial primary key,\ntitle text not null,\nauthor_id int references author(id) -- this defines the foreign key\n);\n</code></pre> <p>To apply the best practice of indexing foreign keys, an index is needed on the <code>book.author_id</code> column. We can create that index using:</p> <pre><code>create index ix_book_author_id on book(author_id);\n</code></pre> <p>In this case we used the default B-tree index type. Be sure to choose an index type that is appropriate for the data types and use case when working with your own tables.</p>"},{"location":"0001_unindexed_foreign_keys/#example","title":"Example","text":"<p>Let's look at a practical example involving two tables: <code>order_item</code> and <code>customer</code>, where <code>order_item</code> references <code>customer</code>.</p> <p>Given the schema:</p> <pre><code>create table customer (\nid serial primary key,\nname text not null\n);\n\ncreate table order_item (\nid serial primary key,\norder_date date not null,\ncustomer_id integer not null references customer (id)\n);\n</code></pre> <p>We expect the tables to be joined on the condition</p> <pre><code>customer.id = order_item.customer_id\n</code></pre> <p>As in:</p> <pre><code>select\ncustomer.name,\norder_item.order_date\nfrom\ncustomer\njoin order_item\non customer.id = order_item.customer_id\n</code></pre> <p>Using Postgres' \"explain plan\" functionality, we can see how its query planner expects to execute the query.</p> <pre><code>Hash Join  (cost=38.58..74.35 rows=2040 width=36)\n  Hash Cond: (order_item.customer_id = customer.id)\n  -&gt;  Seq Scan on order_item  (cost=0.00..30.40 rows=2040 width=8)\n  -&gt;  Hash  (cost=22.70..22.70 rows=1270 width=36)\n        -&gt;  Seq Scan on customer  (cost=0.00..22.70 rows=1270 width=36)\n</code></pre> <p>Notice that the condition <code>order_item.customer_id = customer.id</code> is being serviced by a <code>Seq Scan</code>, a sequential scan across the <code>order_items</code> table. That means Postgres intends to sequentially iterate over each row in the table to identify the value of <code>customer_id</code>.</p> <p>Next, if we index <code>order_item.customer_id</code> and recompute the query plan:</p> <pre><code>create index ix_order_item_customer_id on order_item(customer_id);\n\nexplain\nselect\ncustomer.name,\norder_item.order_date\nfrom\ncustomer\njoin order_item\non customer.id = order_item.customer_id\n</code></pre> <p>We get the query plan:</p> <pre><code>Hash Join  (cost=38.58..74.35 rows=2040 width=36)\n  Hash Cond: (order_item.customer_id = customer.id)\n  -&gt;  Seq Scan on order_item  (cost=0.00..30.40 rows=2040 width=8)\n  -&gt;  Hash  (cost=22.70..22.70 rows=1270 width=36)\n        -&gt;  Seq Scan on customer  (cost=0.00..22.70 rows=1270 width=36)\n</code></pre> <p>Note that nothing changed.</p> <p>We get an identical result because Postgres' query planner is clever enough to know that a <code>Seq Scan</code> over an empty table is extremely fast, so theres no reason for it to reach out to an index. As more rows are inserted into the <code>order_item</code> table the tradeoff between sequentially scanning and retriving the index steadily tip in favor of the index. Rather than manually finding this inflection point, we can hint to the query planner that we'd like to use indexes by disabling sequentials scans except where they are the only available option. To provides that hint we can use:</p> <pre><code>set local enable_seqscan = off;\n</code></pre> <p>With that change:</p> <pre><code>set local enable_seqscan = off;\n\nexplain\nselect\ncustomer.name,\norder_item.order_date\nfrom\ncustomer\njoin order_item\non customer.id = order_item.customer_id\n</code></pre> <p>We get the query plan:</p> <pre><code>Hash Join  (cost=79.23..159.21 rows=2040 width=36)\n  Hash Cond: (order_item.customer_id = customer.id)\n  -&gt;  Index Scan using ix_order_item_customer_id on order_item  (cost=0.15..74.75 rows=2040 width=8)\n  -&gt;  Hash  (cost=63.20..63.20 rows=1270 width=36)\n        -&gt;  Index Scan using customer_pkey on customer  (cost=0.15..63.20 rows=1270 width=36)\n</code></pre> <p>The new plan services the <code>order_item.customer_id = customer.id</code> join condition using an <code>Index Scan</code> on <code>ix_order_item_customer_id</code> which is far more efficient at scale.</p>"},{"location":"0002_auth_users_exposed/","title":"Auth Users Exposed","text":"<p>Level: WARN</p>"},{"location":"0002_auth_users_exposed/#rationale","title":"Rationale","text":"<p>Referencing the <code>auth.users</code> table in a view can inadvertently expose more data than intended.</p>"},{"location":"0002_auth_users_exposed/#why-shouldnt-you-expose-authusers-with-a-view","title":"Why shouldn't you expose auth.users with a view?","text":"<p><code>auth.users</code> is the primary table that backs Supabase Auth. It contains detailed information about each of your projects users, their login methods, and other personally identifiable information.</p> <p>In Postgres, the built in mechanism for controlling access to rows within a table is row level security (RLS). By default, views in Postgres are \"security definer\" which means they do not respect RLS rules associated with the tables in the view's query. Materialized views similarly don't support RLS.</p> <p>As a result, a <code>public</code> security definer view referencing <code>auth.users</code> exposes all user records to all API users, which is likely not what application developers intended.</p>"},{"location":"0002_auth_users_exposed/#how-to-resolve","title":"How to Resolve","text":"<p>There are 2 recommended solutions for exposing user data to your application.</p>"},{"location":"0002_auth_users_exposed/#trigger-on-authusers","title":"Trigger on auth.users","text":"<p>This option involves creating a table in the public schema, e.g. <code>public.profiles</code>, containing a subset of columns from <code>auth.users</code> that are appropriate for your application's use case. You can then set a trigger on <code>auth.users</code> to automatically insert the relevant data into <code>public.profiles</code> any time a new user is inserted into <code>auth.users</code>.</p> <p>Note that triggers execute in the same transaction as the insert into <code>auth.users</code> so you must check the trigger logic carefully as any errors could block user signups to your project.</p> <p>An additional benefit of this approach is that the <code>public.profiles</code> table provides a logical place to store any additional user metadata that is needed for the application.</p> <p>To start we need a location to store public user data in the <code>public</code> schema:</p> <pre><code>create table public.profiles (\nid uuid not null references auth.users on delete cascade,\nfirst_name text,\nlast_name text,\n\nprimary key (id)\n);\n</code></pre> <p>Next, we create a trigger function to copy the data from <code>auth.users</code> into <code>public.profiles</code> when new rows are inserted</p> <pre><code>-- inserts a row into public.profiles\ncreate function public.handle_new_user()\nreturns trigger\nlanguage plpgsql\nsecurity definer set search_path = public\nas $$\nbegin\ninsert into public.profiles (id, first_name, age)\nvalues (new.id, new.raw_user_meta_data -&gt;&gt; 'first_name', new.raw_user_meta_data['age']::integer);\nreturn new;\nend;\n$$;\n\n-- trigger the function every time a user is created\ncreate trigger on_auth_user_created\nafter insert on auth.users\nfor each row execute procedure public.handle_new_user();\n</code></pre> <p>Finally, we can create row level security policies on the <code>public.profiles</code> schema to restrict access to certain operations:</p> <pre><code>alter table public.profiles enable row level security;\n\ncreate policy \"Public profiles are viewable by everyone.\"\non profiles for select\nusing ( true );\n\ncreate policy \"Users can update own profile.\"\non profiles for update\nusing ( auth.uid() = id );\n</code></pre> <p>For more information on this approach see the auth docs.</p>"},{"location":"0002_auth_users_exposed/#security-invoker-view-with-rls-on-authusers","title":"Security Invoker View with RLS on auth.users","text":"<p>The second recommended approach to securely exposing <code>auth.users</code> data is to create a view with the configuration option <code>security_invoker=on</code>. That setting, introduced in Postgres 15, tells the view to respect the RLS policies associated with the underlying tables from the query. Next, we can enable RLS on <code>auth.users</code> and create any policy we need to restrict access to the data.</p> <p>To enable security invoker mode on the view we can use the <code>with (security_invoker=on)</code> clause:</p> <pre><code>create view public.members\nwith (security_invoker=on)\nas\nselect\nid,\nraw_user_meta_data -&gt;&gt; 'first_name' as first_name,\ncreated_at\nfrom\nauth.users;\n</code></pre> <p>Next, grant permissions and enable RLS on <code>auth.users</code>:</p> <pre><code>grant select on auth.users to authenticated;\nalter table auth.users enable row level security;\n</code></pre> <p>and finally, create a policy defining which users should be able to see each record:</p> <pre><code>create policy select_self on auth.users\nfor select\nusing ((select auth.uid()) = id);\n</code></pre>"},{"location":"0003_auth_rls_initplan/","title":"Auth RLS InitPlan","text":"<p>Level: WARN</p>"},{"location":"0003_auth_rls_initplan/#rationale","title":"Rationale","text":"<p>Row-Level Security (RLS) policies are the mechanism for controlling access to data based on user roles or attributes. These policies frequently use the provided helper functions in the <code>auth</code> schema including <code>auth.uid()</code>, <code>auth.role()</code>, <code>auth.email()</code>, and <code>auth.jwt()</code> to retrieve information about the current querying user. Improperly written RLS policies can cause these functions to execute once-per-row, rather than once-per-query. While the <code>auth.&lt;value&gt;()</code> functions are efficient, if executed once-per-row they can lead to significant performance bottlenecks at scale.</p>"},{"location":"0003_auth_rls_initplan/#the-performance-issue","title":"The Performance Issue","text":"<p>When an RLS policy is applied to a query, the conditions specified in the policy are evaluated for each row that the query touches. This means that if a policy condition calls a helper function like <code>auth.uid()</code>, this function is executed repeatedly for every row. In queries affecting thousands of rows, this behavior can drastically reduce query performance, as the overhead of executing these functions adds up quickly.</p>"},{"location":"0003_auth_rls_initplan/#how-to-resolve","title":"How to Resolve","text":"<p>To optimize the performance of RLS policies using <code>auth</code> helper functions we aim to reduce the number of times the helper functions are called. This can be achieved by caching the result of the function call for the duration of the query. Instead of calling the function directly in the policy condition, you can wrap the function call in a subquery. This approach executes the function once, caches the result, and compares this cached value against the column values for all subsequent rows.</p> <p>For example, consider the policy:</p> <pre><code>create policy \"inefficient_document_access\" on documents\nto authenticated\nusing ( auth.uid() = creator_id );\n</code></pre> <p>In this policy, <code>auth.uid()</code> is called for every row in the <code>documents</code> table to check if the <code>creator_id</code> matches the current user's ID. If the number of rows in <code>documents</code> is 150,000 the <code>auth.uid()</code> function will be executed 150,000, potentially incurring over 3 seconds of overhead per query.</p> <p>If we wrap the <code>auth.uid()</code> call in a subquery:</p> <pre><code>create policy \"efficient_document_access\" on user_data\nto authenticated\nusing ( (select auth.uid()) = user_id );\n</code></pre> <p>Then auth.uid() is called only once at the beginning of the query execution, and its result is reused for each row comparison. That change reduces the overhead from a few seconds to a few microseconds with no impact on the result set.</p> <p>Since the output values for the <code>auth</code> helper functions are set on a per-query basis there is no downside to aggresively applying this performacne optimization.</p>"},{"location":"0004_no_primary_key/","title":"No Primary Key","text":"<p>Level: INFO</p>"},{"location":"0004_no_primary_key/#rationale","title":"Rationale","text":"<p>Tables in a relational database should ideally have a key that uniquely identifies a row within that table. Tables lacking a primary key is often considered poor design, as it can lead to data anomalies, complicate data relationships, and degrade query performance.</p>"},{"location":"0004_no_primary_key/#what-is-a-primary-key","title":"What is a Primary Key?","text":"<p>A primary key is a single column or a set of columns that uniquely identifies each row in a table.</p> <p>Primary keys are important because they enable:</p> <ol> <li>Uniqueness and Integrity: Ensures that each row in the table is unique and identifiable.</li> <li>Performance: The database automatically creates an index for the primary key, improving query performance when retrieving or manipulating data based on the primary key.</li> <li>Relationships: Unique keys, like primary keys, are a prerequisite for defining foreign keys in other tables, which are critical for relational database design and efficient joins.</li> </ol>"},{"location":"0004_no_primary_key/#how-to-resolve","title":"How to Resolve","text":"<p>For a table that lacks a primary key, the resolution involves identifying a column (or a set of columns) that can uniquely identify each row and altering the table to designate those columns as the primary key.</p> <p>Given a table:</p> <pre><code>create table customer (\nid integer not null,\nname text not null,\nemail text not null\n-- Notice the lack of a PRIMARY KEY constraint\n);\n</code></pre> <p>If we assume <code>id</code> is unique for each customer, we can add a primary key constraint to the table using:</p> <pre><code>alter table customer add primary key (id);\n</code></pre> <p>If no single column can serve as a unique identifier, consider using a composite key. A composite key combines multiple columns to form a unique identifier for each row.</p> <p>Example:</p> <p>Consider a table event_log that logs user activities without a primary key:</p> <pre><code>create table event_log (\nuser_id integer not null,\nevent_time timestamp not null,\naction text not null\n-- A combination of user_id and event_time can uniquely identify rows\n);\n</code></pre> <p>To resolve the lack of a primary key and ensure that each log entry is uniquely identifiable, we can add a composite primary key on user_id and event_time:</p> <pre><code>alter table event_log add primary key (user_id, event_time);\n</code></pre> <p>Ensure every table has a primary key, even if it's a synthetic key that doesn't have a natural counterpart in the data model. When possible, use a simple fixed size types like <code>int</code>, <code>bigint</code>, and <code>uuid</code> as the primary key for maximum efficiency.</p>"},{"location":"0005_unused_index/","title":"Unused Index","text":"<p>Level: INFO</p>"},{"location":"0005_unused_index/#rationale","title":"Rationale","text":"<p>Unused indexes in a database are a silent performance issue. While indexes are important for speeding up search queries, every index also adds overhead to the database. This overhead occurs because the database must update each index whenever data in the indexed table are inserted, updated, or deleted. If an index is never used by your queries, it burdens the database with unnecessary work, which can slow down write operations and consume additional storage space.</p>"},{"location":"0005_unused_index/#what-is-an-index","title":"What is an Index?","text":"<p>An index in a database is similar to an index in a book. It allows the database to find data without scanning the entire table. An index is created on a column or a set of columns in a table. Queries that search or sort data based on these columns can find data more quickly and efficiently by referring the index instead of each row in the table.</p>"},{"location":"0005_unused_index/#what-are-unused-indexes","title":"What are Unused Indexes","text":"<p>Unused indexes are indexes that have not been accessed by any query execution plans. This might occur if indexes were created proactively to support potential future query patterns or if application usage patterns change after a schema migration.</p>"},{"location":"0005_unused_index/#how-to-resolve","title":"How to Resolve","text":"<p>Before deleting an index, it's important to confirm that the index is genuinely unused and was unintentionally created:</p> <ul> <li>Consider future usage patterns. An index might be unused now but could be critical for upcoming features or during specific times of the year.</li> <li>Test the impact of removing the index in a development or staging environment to ensure that performance or query plans are not adversely affected.</li> </ul> <p>To remove an unused index, use the <code>drop index</code> statement:</p> <pre><code>drop index &lt;schema_name&gt;.&lt;index_name&gt;;\n</code></pre> <p>Replacing <code>schema_name</code> and <code>index_name</code> with the actual names from your database.</p>"},{"location":"0006_multiple_permissive_policies/","title":"Multiple Permissive Policies","text":"<p>Level: WARN</p>"},{"location":"0006_multiple_permissive_policies/#rationale","title":"Rationale","text":"<p>In Postgres, Row Level Security (RLS) policies control access to rows in a table based on the executing user. When multiple permissive policies are applied to the same table the user may have access to a selected row through any of those policies. This means that, in the worst case, all of the relevant RLS policies must be applied/tested before Postgres can determine if a row should be visible. At scale, these checks add significant overhead to SQL queries and can be a performance bottleneck.</p>"},{"location":"0006_multiple_permissive_policies/#row-level-security-policies","title":"Row Level Security Policies","text":"<p>RLS policies in Postgres are rules applied to tables that determine whether rows can be selected, inserted, updated, or deleted. These policies can be set to <code>PERMISSIVE</code> or <code>RESTRICTIVE</code>. Permissive policies allow actions unless explicitly restricted by a restrictive policy. When multiple permissive policies are defined for a table, they act in a cumulative manner \u2014 if any policy allows access, the access is granted. In other words, the policies compose with <code>OR</code> semantics.</p>"},{"location":"0006_multiple_permissive_policies/#risks-with-multiple-permissive-policies","title":"Risks with Multiple Permissive Policies","text":""},{"location":"0006_multiple_permissive_policies/#access-control","title":"Access Control","text":"<p>Multiple permissive policies on a table can make it challenging to accurately predict and control which rows are accessible to different users. This complexity can inadvertently lead to overly permissive access configurations, undermining data security and integrity.</p>"},{"location":"0006_multiple_permissive_policies/#performance","title":"Performance","text":"<p>Since any one of N permissive policies can provide a user access to a given table's row, in the worst case Postgres must execute all N policies to determine if a row should be visible. These multiple checks raise the probability of a query falling off an index and broadly increase the resource consumption of every query on the impacted table.</p>"},{"location":"0006_multiple_permissive_policies/#how-to-resolve","title":"How to Resolve","text":"<p>Consider a table <code>employee_data</code> with two permissive policies:</p> <p>Policy A allows access to employees in the same department. Policy B allows access to employees at or above a certain grade level.</p> <p>Our intention is for users to be able to see employee data for employees within their own department who are below the querying user's grade level.</p> <pre><code>-- Policy A\ncreate policy department_access on employee_data\nfor select\nusing (department = current_user_department());\n\n-- Policy B\ncreate policy grade_level_access on employee_data\nfor select\nusing (grade_level &lt;= current_user_grade_level());\n</code></pre> <p>The implementation contains a logic error. As written, every employee can see <code>employee_data</code> for every other employee within their departemnt. Similarly, every employee can see every other employee's data at or below their own grade level.</p> <p>To address this issue, we can combine the two policies.</p> <pre><code>drop policy department_access on employee_data;\ndrop policy grade_level_access on employee_data;\n\ncreate policy consolidated_access on employee_data\nfor select\nusing (\ndepartment = current_user_department()\nor grade_level &gt;= current_user_grade_level()\n);\n</code></pre> <p>In addition to addressing the logic bug, we have also improved the Postgres query planner's ability to inline the policy to check access to rows, which reduces the chance of the query falling off index.</p> <p>While consolidating RLS policies for a given role/action combination is a best practices, it is not a hard rule. If consolidating policies leads to unreadable SQL then you may opt to have multiple policies for maintainability.</p>"},{"location":"0007_policy_exists_rls_disabled/","title":"Policy Exists RLS Disabled","text":"<p>Level: INFO</p>"},{"location":"0007_policy_exists_rls_disabled/#rationale","title":"Rationale","text":"<p>In Postgres, Row Level Security (RLS) policies control access to rows in a table based on the executing user. Policies can be created, but will not be enforced until the table is updated to enable row level security. Failing to enable row level security is a common misconfiguration that can lead to data leaks.</p>"},{"location":"0007_policy_exists_rls_disabled/#how-to-resolve","title":"How to Resolve","text":"<p>To enable existing policies on a table execute:</p> <pre><code>alter table &lt;schema&gt;.&lt;table&gt; enable row level security;\n</code></pre>"},{"location":"0007_policy_exists_rls_disabled/#example","title":"Example","text":"<p>Given the schema:</p> <pre><code>create table public.blog(\nid int primary key,\nuser_id uuid not null,\ntitle text not null\n);\n\ncreate policy select_own_posts on public.blog\nfor select\nusing ((select auth.uid()) = user_id);\n</code></pre> <p>A user may incorrectly believe that their policies are being applied. Before the policies will take effect, we first must enable row level security on the underlying table.</p> <pre><code>alter table public.blog enable row level security;\n</code></pre>"},{"location":"0008_rls_enabled_no_policy/","title":"RLS Enabled No Policy","text":"<p>Level: INFO</p>"},{"location":"0008_rls_enabled_no_policy/#rationale","title":"Rationale","text":"<p>In Postgres, Row Level Security (RLS) policies control access to rows in a table based on the executing user. If a table has RLS enabled, but no policies exist, no data will be selectable via Supabase APIs.</p>"},{"location":"0008_rls_enabled_no_policy/#how-to-resolve","title":"How to Resolve","text":"<p>If a table has RLS enabled with no policies, you can resolve the issue by creating a policy on the table</p> <p>For example:</p> <pre><code>create policy select_own_posts on public.blog\nfor select\nusing ((select auth.uid()) = user_id);\n</code></pre>"},{"location":"0008_rls_enabled_no_policy/#example","title":"Example","text":"<p>Given the schema:</p> <pre><code>create table public.blog(\nid int primary key,\nuser_id uuid not null,\ntitle text not null\n);\n\nalter table public.blog enable row level security;\n</code></pre> <p>No data will be selectable from the public.blog table over Supabase APIs.</p> <p>To resolve the issue, create a policy on <code>public.blog</code> to grant some level of access</p> <pre><code>create policy select_own_posts on public.blog\nfor select\nusing ((select auth.uid()) = user_id);\n</code></pre> <p>Note that some users may enable RLS with no policies intentionally to restrict access over APIs. In those cases we recommend making that intent explicit with a rejection policy.</p> <pre><code>create policy none_shall_pass on public.blog\nfor select\nusing (false);\n</code></pre>"},{"location":"0009_duplicate_index/","title":"Duplicate Index","text":"<p>Level: WARN</p>"},{"location":"0009_duplicate_index/#rationale","title":"Rationale","text":"<p>Each index in a Postgres database adds overhead. This overhead occurs because the database must update each index whenever data in the indexed table are inserted, updated, or deleted. If two or more indexes are exact duplicates in their composition, the database incurs additional write overhead for no performance benefit.</p>"},{"location":"0009_duplicate_index/#what-is-an-index","title":"What is an Index?","text":"<p>An index in a database is similar to an index in a book. It allows the database to find data without scanning the entire table. An index is created on a column or a set of columns in a table. Queries that search or sort data based on these columns can find data more quickly and efficiently by referring the index instead of each row in the table.</p>"},{"location":"0009_duplicate_index/#how-to-resolve","title":"How to Resolve","text":"<p>When a table contains a duplicate index, drop instances of the index until only one remains.</p> <p>For example, if the table <code>public.blog</code> has duplicate indexes <code>public.ix_id_1</code> and <code>public.ix_id_2</code> drop one using:</p> <pre><code>drop index public.ix_id_2;\n</code></pre>"},{"location":"0010_security_definer_view/","title":"Security Definer View","text":"<p>Level: WARN</p>"},{"location":"0010_security_definer_view/#rationale","title":"Rationale","text":"<p>Postgres' default setting for views is SECURITY DEFINER which means they use the permissions of the view's creator, rather than the permissions of the querying user when executing the view's underlying query. That is an unintuitive default, chosen for backwards compatibility with older Postgres versions, which makes it easy to accidentally expose more data in views than was intended.</p>"},{"location":"0010_security_definer_view/#understanding-security-definer-and-security-invoker","title":"Understanding SECURITY DEFINER and SECURITY INVOKER","text":"<p>In PostgreSQL, a view can be defined with either the SECURITY DEFINER or SECURITY INVOKER option.</p> <ul> <li> <p>SECURITY DEFINER: This setting causes the view or function to run with the privileges of the user who created it, regardless of the user who invokes it. This can be useful for allowing a less-privileged user to perform specific tasks that require higher privileges but poses a significant security risk if not handled carefully. It is common for views to be created by highly privileged users with the ability to bypass row level security which further exacerbates the risk.</p> </li> <li> <p>SECURITY INVOKER: Conversely, with SECURITY INVOKER, the view or function executes with the privileges of the user calling it, respecting the principle of least privilege and significantly reducing the risk of unintentional privilege escalation.</p> </li> </ul>"},{"location":"0010_security_definer_view/#the-risk-of-security-definer-views-in-public-schema","title":"The Risk of SECURITY DEFINER Views in Public Schema","text":"<p>Creating a view in the public schema makes that view accessible via your project's APIs. If the view is created through Supabase Studio or using the Supabase CLI in SECURITY DEFINER mode, the view will bypass row level security rules and could expose more data publically over the project's APIs than the developer intended.</p>"},{"location":"0010_security_definer_view/#how-to-resolve","title":"How to Resolve","text":"<p>To mitigate the risk, always set <code>with (security_invoker=on)</code> when a view should respect RLS policies.</p> <p>Given the view:</p> <pre><code>create view public.order_items\nas\nselect\nid,\n...\nfrom\napp.order_items;\n</code></pre> <p>Enable SECURITY INVOKER mode using:</p> <pre><code>create view public.order_items\nwith (security_invoker=on)\nas\nselect\nid,\n...\nfrom\napp.order_items;\n</code></pre>"},{"location":"0011_function_search_path_mutable/","title":"Function Search Path Mutable","text":"<p>Level: WARN</p>"},{"location":"0011_function_search_path_mutable/#rationale","title":"Rationale","text":"<p>In PostgreSQL, the <code>search_path</code> determines the order in which schemas are searched to find unqualified objects (like tables, functions, etc.). Setting <code>search_path</code> explicitly for a function is a best practice that ensures its behavior is consistent and secure, regardless of the executing user's default <code>search_path</code> settings. We recommend pinning funtions' <code>search_path</code> to an empty string, <code>search_path = ''</code>, which forces all references within the function's body to be fully qualified. This helps prevent unexpected behavior due to changes in the <code>search_path</code> and mitigates potential security vulnerabilities.</p>"},{"location":"0011_function_search_path_mutable/#what-is-the-search-path","title":"What is the Search Path?","text":"<p>The search path in PostgreSQL is a list of schema names that PostgreSQL checks when trying to resolve unqualified object names like <code>profiles</code>. In contrast, a fully qualified name includes the schema like <code>public.profiles</code>, and always resolves the same way, regardless of the user's <code>search_path</code>. By default, <code>search_path</code> includes the user's schema and the <code>public</code> schema. However, this can lead to unexpected behavior if different users have different <code>search_path</code> settings. Specifically, unqualified references will be resolved differently depending on who is executing the function.</p>"},{"location":"0011_function_search_path_mutable/#the-issue-with-not-setting-the-search-path-in-functions","title":"The Issue with Not Setting the Search Path in Functions","text":"<p>When a function does not have its <code>search_path</code> explicitly set, it inherits the <code>search_path</code> of the current session when it is invoked. This behavior can lead to several problems:</p> <ul> <li>Inconsistency: The function may behave differently depending on the user's <code>search_path</code> settings.</li> <li>Security Risks: Malicious users could potentially exploit the <code>search_path</code> to direct the function to use unexpected objects, such as tables or other functions, that the malicious user controls.</li> </ul>"},{"location":"0011_function_search_path_mutable/#how-to-resolve","title":"How to Resolve","text":"<p>To ensure that your functions are secure and behave consistently, set the search path explicitly to an empty string within the function's definition.</p> <p>Given a function like:</p> <pre><code>create function example_function()\nreturns void\nlanguage sql\nas $$\n-- Your SQL code here\n$$;\n</code></pre> <p>You can <code>create or replace</code> the function and add the <code>search_path</code> setting.</p> <pre><code>create or replace function example_function()\nreturns void\nlanguage sql\nset search_path = '' -- LOOK HERE\nas $$\n-- Your SQL code here.\n$$;\n</code></pre> <p>Remember that once you set the <code>search_path = ''</code> all references to tables/functions/views/etc in your function's body must be qualified with a schema name.</p>"},{"location":"0013_rls_disabled_in_public/","title":"RLS Disabled in Public","text":"<p>Level: ERROR</p>"},{"location":"0013_rls_disabled_in_public/#rationale","title":"Rationale","text":"<p>Tables in the <code>public</code> schema are accessible over Supabase APIs. If row level security (RLS) is not enabled on a <code>public</code> table, anyone with the project's URL can CREATE/READ/UPDATE/DELETE (CRUD) rows in the impacted table. Publicly exposing full CRUD to the internet is a critically unsafe configuration.</p>"},{"location":"0013_rls_disabled_in_public/#how-to-resolve","title":"How to Resolve","text":"<p>To enable RLS on a table execute:</p> <pre><code>alter table &lt;schema&gt;.&lt;table&gt; enable row level security;\n</code></pre> <p>Note that after enabling RLS you will not be able to use the <code>anon</code> role to read or write data to the table via Supabase APIs until you create row level security policies to control access.</p>"},{"location":"0013_rls_disabled_in_public/#example","title":"Example","text":"<p>Given the schema:</p> <pre><code>create table public.blog(\nid int primary key,\nuser_id uuid not null,\ntitle text not null\n);\n</code></pre> <p>Any user with access to the project's URL will be able to perform CRUD operations on the <code>public.blog</code> table. To restrict access to users specified in row level security policies, enable RLS with:</p> <pre><code>alter table public.blog enable row level security;\n</code></pre>"},{"location":"0014_extension_in_public/","title":"Extension in Public","text":"<p>Level: WARN</p>"},{"location":"0014_extension_in_public/#rationale","title":"Rationale","text":"<p>Entities like tables and functions in the <code>public</code> schema are exposed through Supabase APIs by default. When extensions are installed in the <code>public</code> schema, the functions, tables, views, etc that they contain appear to be part of your project's API.</p>"},{"location":"0014_extension_in_public/#how-to-resolve","title":"How to Resolve","text":"<p>To relocate an extension from the <code>public</code> schema to another schema, execute:</p> <pre><code>alter extension &lt;some_extension&gt; set schema &lt;some_schema&gt;;\n</code></pre>"},{"location":"0014_extension_in_public/#example","title":"Example","text":"<p>If the <code>ltree</code> extension was initially created in thh <code>public</code> schema with</p> <p><pre><code>create extension ltree;\n</code></pre> or <pre><code>create extension ltree schema public;\n</code></pre></p> <p>You can relocate its components to the <code>extensions</code> schema by running</p> <pre><code>alter extension ltree set schema extensions;\n</code></pre>"},{"location":"0015_rls_references_user_metadata/","title":"RLS References user_metadata","text":"<p>Level: ERROR</p>"},{"location":"0015_rls_references_user_metadata/#rationale","title":"Rationale","text":"<p>Supabase Auth user_metadata is used to set metadata about the user on sign up. It is designed to be manipulated by the user themselves. Because the user can change it (either directly or indirectly by sending a user update API call) to any value (there is no validation) this should not be used to base security policies.</p>"},{"location":"0015_rls_references_user_metadata/#the-risk","title":"The Risk","text":"<p>Row-Level Security (RLS) policies are the mechanism for controlling access to data based on user roles or attributes. Supabase Auth user_metadata allows metadata to be assigned to users, but that metadata can also be manipulated by the end user using client libraries. For example, in supabase-js:</p> <pre><code>updateUser({ data: { is_admin: true } })\n</code></pre> <p>For that reason, it is not safe to rely on the contents of <code>user_metadata</code> in row level security policies.</p> <p>An example insecure policy could be:</p> <pre><code>create policy bad_policy on public.foo\nfor select\nto authenticated\nusing ( (( select auth.jwt() ) -&gt; 'user_metadata' -&gt;&gt; 'is_admin' )::bool );\n</code></pre> <p>The policy is insecure because end users could execute <code>updateUser({ data: { is_admin: true } })</code> to bypass the security check.</p>"},{"location":"0015_rls_references_user_metadata/#how-to-resolve","title":"How to Resolve","text":"<p>There is no one-size-fits-all solution to replacing a RLS policy that references <code>user_metadata</code>.</p> <p>If you're unsure how to refactor your policy to remove its dependance on <code>user_metadata</code> open a ticket with support for assistance.</p>"},{"location":"0017_foreign_table_in_api/","title":"0017 foreign table in api","text":"<p>Level: WARN</p>"},{"location":"0017_foreign_table_in_api/#rationale","title":"Rationale","text":"<p>Postgres' default setting for views is SECURITY DEFINER which means they use the permissions of the view's creator, rather than the permissions of the querying user when executing the view's underlying query. That is an unintuitive default, chosen for backwards compatibility with older Postgres versions, which makes it easy to accidentally expose more data in views than was intended.</p>"},{"location":"0017_foreign_table_in_api/#understanding-security-definer-and-security-invoker","title":"Understanding SECURITY DEFINER and SECURITY INVOKER","text":"<p>In PostgreSQL, a view can be defined with either the SECURITY DEFINER or SECURITY INVOKER option.</p> <ul> <li> <p>SECURITY DEFINER: This setting causes the view or function to run with the privileges of the user who created it, regardless of the user who invokes it. This can be useful for allowing a less-privileged user to perform specific tasks that require higher privileges but poses a significant security risk if not handled carefully. It is common for views to be created by highly privileged users with the ability to bypass row level security which further exacerbates the risk.</p> </li> <li> <p>SECURITY INVOKER: Conversely, with SECURITY INVOKER, the view or function executes with the privileges of the user calling it, respecting the principle of least privilege and significantly reducing the risk of unintentional privilege escalation.</p> </li> </ul>"},{"location":"0017_foreign_table_in_api/#the-risk-of-security-definer-views-in-public-schema","title":"The Risk of SECURITY DEFINER Views in Public Schema","text":"<p>Creating a view in the public schema makes that view accessible via your project's APIs. If the view is created through Supabase Studio or using the Supabase CLI in SECURITY DEFINER mode, the view will bypass row level security rules and could expose more data publically over the project's APIs than the developer intended.</p>"},{"location":"0017_foreign_table_in_api/#how-to-resolve","title":"How to Resolve","text":"<p>To mitigate the risk, always set <code>with (security_invoker=on)</code> when a view should respect RLS policies.</p> <p>Given the view:</p> <pre><code>create view public.order_items\nas\nselect\nid,\n...\nfrom\napp.order_items;\n</code></pre> <p>Enable SECURITY INVOKER mode using:</p> <pre><code>create view public.order_items\nwith (security_invoker=on)\nas\nselect\nid,\n...\nfrom\napp.order_items;\n</code></pre>"}]}