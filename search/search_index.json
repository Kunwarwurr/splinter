{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#splinter","title":"Splinter","text":""},{"location":"0001_unindexed_foreign_keys/","title":"Unindexed Foreign Keys","text":"<p>Level: INFO</p>"},{"location":"0001_unindexed_foreign_keys/#rationale","title":"Rationale","text":"<p>In relational databases, indexing foreign key columns is a standard practice for improving query performance. Indexing these columns is recommended in most cases because it improves query join performance along a declared relationship.</p>"},{"location":"0001_unindexed_foreign_keys/#what-is-a-foreign-key","title":"What is a Foreign Key?","text":"<p>A foreign key is a constraint on a column (or set of columns) that enforces a relationship between two tables. For example, a foreign key from <code>book.author_id</code> to <code>author.id</code> enforces that every value in <code>book.author_id</code> exists in <code>author.id</code>. Once the foriegn key is declared, it is not possible to insert a value into <code>book.author_id</code> that does not exist in <code>author.id</code>. Similarly, Postgres will not allow us to delete a value from <code>author.id</code> that is referenced by <code>book.author_id</code>. This concept is known is referential integrity.</p>"},{"location":"0001_unindexed_foreign_keys/#why-index-foreign-key-columns","title":"Why Index Foreign Key Columns?","text":"<p>Given that foreign keys define relationships among tables, it is common to use foreign key columns in join conditions when querying the database. Adding an index to the columns making up the foreign key improves the performance of those joins and reduces database resource consumption.</p> <pre><code>select\nbook.id,\nbook.title,\nauthor.name\nfrom\nbook\njoin author\n-- Both sides of the following condition should be indexed\n-- for best performance\non book.author_id = author.id\n</code></pre>"},{"location":"0001_unindexed_foreign_keys/#how-to-resolve","title":"How to Resolve","text":"<p>Given a table:</p> <pre><code>create table book (\nid serial primary key,\ntitle text not null,\nauthor_id int references author(id) -- this defines the foreign key\n);\n</code></pre> <p>To apply the best practice of indexing foreign keys, an index is needed on the <code>book.author_id</code> column. We can create that index using:</p> <pre><code>create index ix_book_author_id on book(author_id);\n</code></pre> <p>In this case we used the default B-tree index type. Be sure to choose an index type that is appropriate for the data types and use case when working with your own tables.</p>"},{"location":"0001_unindexed_foreign_keys/#example","title":"Example","text":"<p>Let's look at a practical example involving two tables: <code>order_item</code> and <code>customer</code>, where <code>order_item</code> references <code>customer</code>.</p> <p>Given the schema:</p> <pre><code>create table customer (\nid serial primary key,\nname text not null\n);\n\ncreate table order_item (\nid serial primary key,\norder_date date not null,\ncustomer_id integer not null references customer (id)\n);\n</code></pre> <p>We expect the tables to be joined on the condition</p> <pre><code>customer.id = order_item.customer_id\n</code></pre> <p>As in:</p> <pre><code>select\ncustomer.name,\norder_item.order_date\nfrom\ncustomer\njoin order_item\non customer.id = order_item.customer_id\n</code></pre> <p>Using Postgres' \"explain plan\" functionality, we can see how its query planner expects to execute the query.</p> <pre><code>Hash Join  (cost=38.58..74.35 rows=2040 width=36)\n  Hash Cond: (order_item.customer_id = customer.id)\n  -&gt;  Seq Scan on order_item  (cost=0.00..30.40 rows=2040 width=8)\n  -&gt;  Hash  (cost=22.70..22.70 rows=1270 width=36)\n        -&gt;  Seq Scan on customer  (cost=0.00..22.70 rows=1270 width=36)\n</code></pre> <p>Notice that the condition <code>order_item.customer_id = customer.id</code> is being serviced by a <code>Seq Scan</code>, a sequential scan across the <code>order_items</code> table. That means Postgres intends to sequentially iterate over each row in the table to identify the value of <code>customer_id</code>.</p> <p>Next, if we index <code>order_item.customer_id</code> and recompute the query plan:</p> <pre><code>create index ix_order_item_customer_id on order_item(customer_id);\n\nexplain\nselect\ncustomer.name,\norder_item.order_date\nfrom\ncustomer\njoin order_item\non customer.id = order_item.customer_id\n</code></pre> <p>We get the query plan:</p> <pre><code>Hash Join  (cost=38.58..74.35 rows=2040 width=36)\n  Hash Cond: (order_item.customer_id = customer.id)\n  -&gt;  Seq Scan on order_item  (cost=0.00..30.40 rows=2040 width=8)\n  -&gt;  Hash  (cost=22.70..22.70 rows=1270 width=36)\n        -&gt;  Seq Scan on customer  (cost=0.00..22.70 rows=1270 width=36)\n</code></pre> <p>Note that nothing changed.</p> <p>We get an identical result because Postgres' query planner is clever enough to know that a <code>Seq Scan</code> over an empty table is extremely fast, so theres no reason for it to reach out to an index. As more rows are inserted into the <code>order_item</code> table the tradeoff between sequentially scanning and retriving the index steadily tip in favor of the index. Rather than manually finding this inflection point, we can hint to the query planner that we'd like to use indexes by disabling sequentials scans except where they are the only available option. To provides that hint we can use:</p> <pre><code>set local enable_seqscan = off;\n</code></pre> <p>With that change:</p> <pre><code>set local enable_seqscan = off;\n\nexplain\nselect\ncustomer.name,\norder_item.order_date\nfrom\ncustomer\njoin order_item\non customer.id = order_item.customer_id\n</code></pre> <p>We get the query plan:</p> <pre><code>Hash Join  (cost=79.23..159.21 rows=2040 width=36)\n  Hash Cond: (order_item.customer_id = customer.id)\n  -&gt;  Index Scan using ix_order_item_customer_id on order_item  (cost=0.15..74.75 rows=2040 width=8)\n  -&gt;  Hash  (cost=63.20..63.20 rows=1270 width=36)\n        -&gt;  Index Scan using customer_pkey on customer  (cost=0.15..63.20 rows=1270 width=36)\n</code></pre> <p>The new plan services the <code>order_item.customer_id = customer.id</code> join condition using an <code>Index Scan</code> on <code>ix_order_item_customer_id</code> which is far more efficient at scale.</p>"},{"location":"0002_auth_users_exposed/","title":"Auth Users Exposed","text":"<p>TODO</p>"},{"location":"0003_auth_rls_initplan/","title":"Auth RLS InitPlan","text":"<p>TODO</p>"},{"location":"0004_no_primary_key/","title":"No Primary Key","text":"<p>TODO</p>"},{"location":"0005_unused_index/","title":"Unused Index","text":"<p>TODO</p>"},{"location":"0006_multiple_permissive_policies/","title":"Multiple Permissive Policies","text":"<p>TODO</p>"}]}